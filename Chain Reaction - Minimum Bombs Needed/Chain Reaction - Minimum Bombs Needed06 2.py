#!/usr/bin/env python3

"""ОПИСАНИЕ:
Это продолжение Chain Reaction - Explosions с теми же настройками, но с другим
вкусом. Как и в предыдущей части, вам будет предоставлен прямоугольный массив,
представляющий "карту" с тремя типами пробелов:

Бомбы "+": при активации их взрыв активирует любые бомбы непосредственно над,
под, слева или справа от бомбы "+".
Бомбы "x": при активации их взрыв активирует любые бомбы, размещенные в любом
из четырех диагональных направлений рядом с бомбой "x".
Пустые пробелы "0".

Цель проста: получив карту, верните минимальное количество бомб, которые
необходимо взорвать, чтобы все бомбы были уничтожены в результате цепной
реакции.
Давайте рассмотрим несколько примеров:
[
["+", "+", "+", "0", "+", "+", "+"],
["+", "+", "+", "0", "0", "+", "+"]
]
Для карты выше ответ таков 2; чтобы взорвать все бомбы, вам просто нужно
взорвать одну бомбу "+" в правом кластере и одну в левом кластере.
[
["x", "0", "x"],
["x", "x", "x"]
]
Для карты выше ответ таков 3; очевидно, что достаточно установить три нижние
бомбы "x", и не менее трех бомб будет достаточно.
[
["x", "x", "x", "0", "x"],
["x", "x", "x", "x", "x"],
["x", "x", "x", "0", "x"]
]
Для карты выше ответ таков 3; срабатывание трех крайних правых бомб в среднем
ряду сделает свое дело.

Примеры
min_bombs_needed([
["+", "+", "+", "0", "+", "+", "+"],
["+", "+", "+", "0", "0", "+", "+"]
]) ➞ 2

min_bombs_needed([
["x", "0", "x"],
["x", "x", "x"]
]) ➞ 3

min_bombs_needed([
["x", "x", "x", "0", "x"],
["x", "x", "x", "x", "x"],
["x", "x", "x", "0", "x"]
]) ➞ 3
Примечания
Обратите внимание, что как бомбы "+", так и бомбы "x" имеют "дальность взрыва",
равную 1.
"""
from collections import deque

"""MY COMMENT: Реализация алгоритма для бомб типа '+' и для бомб типа 'x'."""


def pprint(matr: list) -> None:
    for row in matr:
        print(row)


def find_p(arr: list) -> tuple:
    """функция ищет первое вхождение символа из '+' в сиске 'arr' и возращает
    координаты вхождения 'i, j'. Если вхождение не найдено,
    то возвращает '(-1,-1), None'."""
    for i, row in enumerate(arr):
        for j, el in enumerate(row):
            if el == '+':
                return i, j, '+'
    return -1, -1, None


def find_x(arr: list) -> tuple:
    """функция ищет первое вхождение символа 'x' в сиске 'arr' и возращает
    координаты вхождения 'i, j'. Если вхождение не найдено,
    то возвращает '(-1,-1), None'."""
    for i, row in enumerate(arr):
        for j, el in enumerate(row):
            if el == 'x':
                return i, j, 'x'
    return -1, -1, None


def find_bomb(arr: list) -> tuple:
    """функция ищет первое вхождение любого символа из '+x' в сиске 'arr'
    и возращает координаты вхождения 'i, j' и сам элемент 'el'. Если вхождение
    не найдено, то возвращает '(-1,-1), None'.."""
    for i, row in enumerate(arr):
        for j, el in enumerate(row):
            if el in '+x':
                return i, j, el
    return -1, -1, None


def get_morest(arr: list) -> int:
    """Функция определяет каких бомб больше '+' или 'x'. И возвращает 1, если
    '+'  больше, или 2, если 'x' больше."""
    cp, cx = 0, 0
    for row in arr:
        cp = cp + row.count('+')
        cx = cx + row.count('x')
    if cp >= cx:
        return 1
    else:
        return 2


def blow_bombs(a: list, bomb_pos: tuple, bomb_type: str, p: deque, x: deque):
    """Эта функция получвет координаты бомбы (i,j), с которой запускается взрыв,
    взрывает бомбы до тех пор пока цепочка не прервётся. Возвращает массив 'a'с
    помеченными символом '`' взорванными бомбами."""

    # список приращений координат в виде очереди.
    incr = deque([])
    # бомбы, которые уже взорваны
    blowed = [[bomb_pos, bomb_type]]

    k = 0
    # до тех пор, пока список уже взованных бомб не закончится (цепочка взрывов
    # не прервётся), взрываем очередную бомбу 'current_pos, bomb_type' и
    # записываем в 'blowed' очередную взорванную бомбу 'i, j  и near'.
    while k < len(blowed):
        current_pos, bomb_type = blowed[k]
        i, j = current_pos
        if bomb_type == '+': incr = p
        elif bomb_type == 'x': incr = x
        incr_len = len(incr)

        for _ in range(incr_len):
            di, dj = incr[0]
            i, j = i + di, j + dj
            if len(a) > i >= 0 and len(a[i]) > j >= 0:
                if a[i][j] not in "~0":
                    near = a[i][j]
                    a[i][j] = '~'
                    if [(i, j), near] not in blowed:
                        blowed.append([(i, j), near])
            incr.rotate(-1)
            i, j = current_pos
        k = k + 1

    return a


def get_min_bombs(a: list) -> int:
    p = deque([(0, 0), (0, 1), (1, 0), (-1, 0), (0, -1)])
    x = deque([(0, 0), (-1, 1), (1, 1), (1, -1), (-1, -1)])
    c = 0

    # bomb_type = ''
    # while bomb_type is not None:
    #     r = find_bomb(a)
    #     bomb_pos, bomb_type = (r[0], r[1]), r[2]
    #     if bomb_pos != (-1, -1):
    #         a = blow_bombs(a, bomb_pos, bomb_type, p, x)
    #         c = c + 1
    # return c

    bomb_type = ''
    while bomb_type is not None:
        r = find_x(a)
        bomb_pos, bomb_type = (r[0], r[1]), r[2]
        if bomb_pos != (-1, -1):
            a = blow_bombs(a, bomb_pos, bomb_type, p, x)
            c = c + 1

    bomb_type = ''
    while bomb_type is not None:
        r = find_p(a)
        bomb_pos, bomb_type = (r[0], r[1]), r[2]
        if bomb_pos != (-1, -1):
            a = blow_bombs(a, bomb_pos, bomb_type, p, x)
            c = c + 1

    return c


def main():
    tests = [
        ([["+", "+", "0", "+", "+"],
          ["+", "+", "+", "+", "+"]], 1),

        ([["+", "+", "+", "0", "+", "+", "+"],
          ["+", "+", "+", "0", "0", "+", "+"]], 2),

        ([["+", "+", "0", "+", "0", "+", "+", "+"],
          ["+", "+", "0", "+", "0", "0", "+", "+"]], 3),

        ([["+", "0", "+", "0", "+", "0", "+"],
          ["+", "+", "+", "+", "+", "+", "+"]], 1),

        ([["+", "0", "+", "+", "+", "+", "+"],
          ["+", "+", "+", "0", "0", "+", "+"]], 1),

        ([['0', '+', '+', '0', '+', '0', '+'],
          ['0', '0', '+', '0', '+', '0', '+'],
          ['0', '+', '+', '0', '+', '0', '+']], 3),

        ([["+", "+", "+", "+", "+", "+", "+"],
          ['0', '0', '+', '0', '0', '0', '0'],
          ['0', '0', '+', '0', '0', '0', '0'],
          ["0", "0", "+", "+", "+", "+", "+"]], 1),

        ([['+', '+', '0', '+', '+'],
          ['+', '0', '+', '0', '+'],
          ['+', '+', '0', '+', '+']], 3),

        ([['+', '+', '+', '0', '+', '+', '+'],
          ['+', '+', '+', '0', '+', '+', '+'],
          ['+', '+', '0', '+', '+', '+', '+'],
          ['+', '+', '+', '0', '+', '+', '+'],
          ['+', '+', '+', '+', '0', '+', '+'],
          ['+', '+', '+', '+', '0', '+', '+']], 2),

        ([['+', '+', '+', '0', '+', '+', '+'],
          ['+', '+', '+', '0', '+', '+', '+'],
          ['+', '+', '0', '+', '0', '+', '+'],
          ['+', '+', '+', '0', '+', '+', '+'],
          ['+', '+', '0', '+', '0', '+', '+'],
          ['+', '+', '0', '+', '+', '+', '+']], 3),

        ([["x", "0", "x"],
          ["x", "x", "x"]], 3),

        ([["x", "x", "x", "0", "x"],
          ["x", "x", "x", "x", "x"],
          ["x", "x", "x", "0", "x"]], 3),

        ([["x", "0", "x"],
          ["x", "x", "x"]], 3),

        ([["x", "x", "x", "0", "x"],
          ["x", "x", "x", "x", "x"],
          ["x", "x", "x", "0", "x"]], 3),

        ([['x'],
          ['+']], 1),

        ([['+', '0', 'x', '+'],
          ['x', '+', 'x', '+'],
          ['x', '0', '+', '0'],
          ['0', '+', 'x', 'x'],
          ['+', '0', '+', 'x']], 4),

        ([['x', '+', 'x', '+', '+', '+'],
          ['x', 'x', '0', '0', 'x', 'x'],
          ['x', '+', 'x', 'x', '0', 'x'],
          ['0', 'x', 'x', '0', '+', '+'],
          ['+', '+', 'x', '+', '0', '+'],
          ['0', '+', '+', 'x', '+', '+']], 2)
    ]
    for t in tests:
        res = get_min_bombs(t[0])
        print(["fail", "passed"][res == t[1]], res)


if __name__ == "__main__":
    main()
