# ! /usr/bin/env python3

"""ОПИСАНИЕ:
У двух целочисленных треугольников есть нечто общее:
В меньшем треугольнике со сторонами (4, 5, 6) значение угла в два раза больше значения другого.
По сути, ∠C = 2(∠B) а периметр p этого треугольника равен:
p = 4 + 5 + 6 = 15

В большем треугольнике со сторонами (7, 9, 12) один его угол равен двойному другому углу. В этом
случае ∠C = 2(∠A) и периметр p этого другого треугольника равен:
p = 7 + 9 + 12 = 28

Треугольник (4, 5, 6) является наименьшим целочисленным треугольником, обладающим этим свойством,
а следующий - (7, 9, 12).
Оба они удовлетворяют этому свойству, наибольший общий делитель (gcd) сторон a, b, c равен единице.
Другим способом: gcd = 1
Первые периметры этих треугольников с соответствующей тройкой сторон треугольника следующие:
Ord num    perimeter (p)    triangle (all with gcd(a, b ,c) = 1)
    1            15           (4, 5, 6)
    2            28           (7, 9, 12)
    3            40           (9, 15, 16)
    4            45           (9, 16, 20)

Нам нужна функция, per_ang_twice() в которую мы вводим число n, порядковый номер последовательности,
и которая сначала выводит массив со значением периметра, а затем список с треугольником или
треугольниками (с одним значением угла, в два раза превышающим значение угла другого треугольника).

Давайте посмотрим предыдущие случаи, примененные к нашей искомой функции:
per_ang_twice(1) == [15, [(4, 5, 6)]]
per_ang_twice(2) == [28, [(7, 9, 12)]]
per_ang_twice(3) == [40, [(9, 15, 16)]]
per_ang_twice(4) == [45, [(9, 16, 20)]]
Значения сторон треугольника должны быть отсортированы.

Если порядковый номер выводит значение периметра, имеющее более одного треугольника, эти последние
должны быть отсортированы по значению первой стороны:
perAngTwice(1016) == [11704, [(304, 5625, 5775), (2025, 3960, 5719)]])
Ваш код будет протестирован для значений периметров до 1.500.000.

Вы найдете несколько советов для специальных целочисленных треугольников по адресу:
https://en.wikipedia.org/wiki/Integer_triangle"""

from math import gcd

tri_dict = dict()
for n in range(1, 1000):
    for m in range(n + 1, 2 * n):
        if gcd(n, m) == 1 and m * m + n * m <= 1500000:
            a = n * n
            b = m * m - a
            c = n * m
            # tri = tuple(sorted((a, b, c)))
            tri = (a, b, c)
            p = sum(tri)
            if p not in tri_dict:
                tri_dict[p] = []
            tri_dict[p].append(tri)
r = list(sorted(tri_dict.keys()))


def per_ang_twice(k):
    return [r[k - 1], sorted([tuple(sorted(t)) for t in tri_dict[r[k - 1]]])]


def main():
    fun = per_ang_twice
    tests = [Б
             (fun(1), [15, [(4, 5, 6)]]),
             (fun(2), [28, [(7, 9, 12)]]),
             (fun(3), [40, [(9, 15, 16)]]),
             (fun(4), [45, [(9, 16, 20)]]),
             (fun(215), [2470, [(715, 729, 1026)]]),
             (fun(1016), [11704, [(304, 5625, 5775), (2025, 3960, 5719)]]),
             ]
    for t in tests:
        print(["fail", "OK"][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
