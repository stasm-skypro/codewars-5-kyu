# ! /usr/bin/env python3

"""ОПИСАНИЕ:
У двух целочисленных треугольников есть нечто общее:
В меньшем треугольнике со сторонами (4, 5, 6) значение угла в два раза больше значения другого.
По сути, ∠C = 2(∠B) а периметр p этого треугольника равен:
p = 4 + 5 + 6 = 15

В большем треугольнике со сторонами (7, 9, 12) один его угол равен двойному другому углу. В этом
случае ∠C = 2(∠A) и периметр p этого другого треугольника равен:
p = 7 + 9 + 12 = 28

Треугольник (4, 5, 6) является наименьшим целочисленным треугольником, обладающим этим свойством,
а следующий - (7, 9, 12).
Оба они удовлетворяют этому свойству, наибольший общий делитель (gcd) сторон a, b, c равен единице.
Другим способом: gcd = 1
Первые периметры этих треугольников с соответствующей тройкой сторон треугольника следующие:
Ord num    perimeter (p)    triangle (all with gcd(a, b ,c) = 1)
    1            15           (4, 5, 6)
    2            28           (7, 9, 12)
    3            40           (9, 15, 16)
    4            45           (9, 16, 20)

Нам нужна функция, per_ang_twice() в которую мы вводим число n, порядковый номер последовательности,
и которая сначала выводит массив со значением периметра, а затем список с треугольником или
треугольниками (с одним значением угла, в два раза превышающим значение угла другого треугольника).

Давайте посмотрим предыдущие случаи, примененные к нашей искомой функции:
per_ang_twice(1) == [15, [(4, 5, 6)]]
per_ang_twice(2) == [28, [(7, 9, 12)]]
per_ang_twice(3) == [40, [(9, 15, 16)]]
per_ang_twice(4) == [45, [(9, 16, 20)]]
Значения сторон треугольника должны быть отсортированы.

Если порядковый номер выводит значение периметра, имеющее более одного треугольника, эти последние
должны быть отсортированы по значению первой стороны:
perAngTwice(1016) == [11704, [(304, 5625, 5775), (2025, 3960, 5719)]])
Ваш код будет протестирован для значений периметров до 1.500.000.

Вы найдете несколько советов для специальных целочисленных треугольников по адресу:
https://en.wikipedia.org/wiki/Integer_triangle"""

from math import gcd, acos
from itertools import combinations


def per_ang_twice(n):
    """a = 4, b = 5, c = 6
       A - corner(b,c)
       B - corner(a,c)
       C - corner(b,a)"""

    def check_combination(tri):
        a, b, c = tri
        if gcd(a, b, c) == 1 and a < b < c:
            try:
                # to convert to grad mult on 57.2956
                A = acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c)) * 57.2956
                B = acos((a ** 2 + c ** 2 - b ** 2) / (2 * c * a)) * 57.2956
                C = acos((b ** 2 + a ** 2 - c ** 2) / (2 * b * a)) * 57.2956

                A, B, C = int(A), int(B), int(C)

                if (A >= 2 * B or A >= 2 * C or B >= 2 * A or B >= 2 * C or C >= 2 * A or
                        C >= 2 * B):
                    p = (a + b + c)
                    tri = tuple(sorted(a, b, c))
                    return [p, [tri]]
            except Exception:
                return

    k = 1
    while k < n:

        k = k + 1


def main():
    fun = per_ang_twice
    tests = [
        (fun(1), [15, [(4, 5, 6)]]),
        (fun(2), [28, [(7, 9, 12)]]),
        (fun(3), [40, [(9, 15, 16)]]),
        (fun(4), [45, [(9, 16, 20)]]),
        (fun(5), [60, [(16, 20, 24)]]),
        (fun(9), [104, [(25, 39, 40)]]),
        (fun(10), [126, [(25, 45, 56)]]),
        # (fun(66), [805, [(144, 276, 385)]]),
        # (fun(70), [510, [(120, 169, 221)]]),
        # (fun(351), [4240, [(729, 1431, 2080)]]),
        # (fun(352), [1653, [(57, 784, 812)]]),
        # (fun(378), [4565, [(784, 1540, 2241)]]),
        # (fun(1016), [11704, [(304, 5625, 5775), (2025, 3960, 5719)]]),
    ]
    for t in tests:
        print(["fail", "OK"][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
