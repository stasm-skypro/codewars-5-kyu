# ! /usr/bin/env python3

"""ОПИСАНИЕ:
У двух целочисленных треугольников есть нечто общее:
В меньшем треугольнике со сторонами (4, 5, 6) значение угла в два раза больше значения другого.
По сути, ∠C = 2(∠B) а периметр p этого треугольника равен:
p = 4 + 5 + 6 = 15

В большем треугольнике со сторонами (7, 9, 12) один его угол равен двойному другому углу. В этом
случае ∠C = 2(∠A) и периметр p этого другого треугольника равен:
p = 7 + 9 + 12 = 28

Треугольник (4, 5, 6) является наименьшим целочисленным треугольником, обладающим этим свойством,
а следующий - (7, 9, 12).
Оба они удовлетворяют этому свойству, наибольший общий делитель (gcd) сторон a, b, c равен единице.
Другим способом: gcd = 1
Первые периметры этих треугольников с соответствующей тройкой сторон треугольника следующие:
Ord num    perimeter (p)    triangle (all with gcd(a, b ,c) = 1)
    1            15           (4, 5, 6)
    2            28           (7, 9, 12)
    3            40           (9, 15, 16)
    4            45           (9, 16, 20)

Нам нужна функция, per_ang_twice() в которую мы вводим число n, порядковый номер последовательности,
и которая сначала выводит массив со значением периметра, а затем список с треугольником или
треугольниками (с одним значением угла, в два раза превышающим значение угла другого треугольника).

Давайте посмотрим предыдущие случаи, примененные к нашей искомой функции:
per_ang_twice(1) == [15, [(4, 5, 6)]]
per_ang_twice(2) == [28, [(7, 9, 12)]]
per_ang_twice(3) == [40, [(9, 15, 16)]]
per_ang_twice(4) == [45, [(9, 16, 20)]]
Значения сторон треугольника должны быть отсортированы.

Если порядковый номер выводит значение периметра, имеющее более одного треугольника, эти последние
должны быть отсортированы по значению первой стороны:
perAngTwice(1016) == [11704, [(304, 5625, 5775), (2025, 3960, 5719)]])
Ваш код будет протестирован для значений периметров до 1.500.000.

Вы найдете несколько советов для специальных целочисленных треугольников по адресу:
https://en.wikipedia.org/wiki/Integer_triangle"""

from math import gcd


def per_ang_twice(k):
    """Функция принмает число 'k' - порядковый номер последовательности, и выодит массив
    со значением периметра, а затем список с треугольником или треугольниками
    (с одним значением угла, в два раза превышающим значение угла другого треугольника).
    """

    # Вычисление n и m в двух разных циклах.
    # nn = [2]
    # for _ in range(1, k):
    #     nn = nn + [nn[-1] + 1] * nn[-1]
    # n = nn[k - 1]

    # mm = [3]
    # prev = nn[0]
    # for i in range(1, len(nn)):
    #     if nn[i] == prev:
    #         mm = mm + [mm[-1] + 1]
    #     else:
    #         mm.append(nn[i] + 1)
    #     prev = nn[i]
    # m = mm[k - 1]

    # Вычисление n и m внутри одного цикла.
    # nn = [2]
    # mm = [3]
    # prev = nn[0]
    # for i in range(1, k):
    #     nn = nn + [nn[-1] + 1] * nn[-1]
    #     if nn[i] == prev:
    #         mm = mm + [mm[-1] + 1]
    #     else:
    #         mm.append(nn[i] + 1)
    #     prev = nn[i]
    # n = nn[k - 1]
    # m = mm[k - 1]

    # Вычисляем n и m в цикле без создания списка.
    n, m = 2, 3
    i = 1
    # right = -1
    while i < k:
        step = n
        n = n + 1
        i = i + step
        # right = i, delta = right - k, m = (2 * n - 1) - delta
        m = (2 * n - 1) - (i - k)

    if gcd(m, n) == 1 and (n*m + m*m) <= 1500000:
        a = n * n
        b = m * m - a
        c = n * m
    # if gcd(a, b, c) == 1:
    #     tri = tuple(sorted((a, b, c)))
    #     p = sum(tri)
    #     return [p, [tri]]
        tri = tuple(sorted((a, b, c)))
        p = sum(tri)
        return [p, [tri]]


def main():
    fun = per_ang_twice
    tests = [
        (fun(1), [15, [(4, 5, 6)]]),
        (fun(2), [28, [(7, 9, 12)]]),
        (fun(3), [40, [(9, 15, 16)]]),
        (fun(4), [45, [(9, 16, 20)]]),
        (fun(5), [60, [(16, 20, 24)]]),
        (fun(9), [104, [(25, 39, 40)]]),
        (fun(10), [126, [(25, 45, 56)]]),
        (fun(66), [805, [(144, 276, 385)]]),
        (fun(70), [510, [(120, 169, 221)]]),
        (fun(215), [2470, [(715, 729, 1026)]]),
        (fun(351), [4240, [(729, 1431, 2080)]]),
        (fun(352), [1653, [(57, 784, 812)]]),
        (fun(378), [4565, [(784, 1540, 2241)]]),
        (fun(1016), [11704, [(304, 5625, 5775), (2025, 3960, 5719)]]),
    ]
    for t in tests:
        print(["fail", "OK"][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
