#! /usr/bin/env python3

"""ОПИСАНИЕ:
Определение: Согласно Википедии, полное двоичное дерево - это двоичное дерево, в котором каждый
уровень, возможно, за исключением последнего, полностью заполнен, а все узлы на последнем уровне
расположены как можно левее". На странице Википедии, упомянутой выше, также упоминается, что
"Двоичные деревья также могут храниться в порядке следования по ширине как неявная структура данных
в массивах, и если дерево является полным двоичным деревом, этот метод не тратит места".
Ваша задача - написать метод (или функцию), который принимает массив (или список, в зависимости от
языка) целых чисел и, предполагая, что массив упорядочен в соответствии с обходом полного двоичного
дерева в порядке, возвращает массив, содержащий значения дерева в порядке ширины.
Пример 1: Пусть входной массив будет [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Этот массив содержит значения
следующего полного двоичного дерева.
                    _ 7_
                  /      \
                4        9
              /   \     / \
            2      6   8   10
           / \     /
          1   3   5

В этом примере входной массив должен быть отсортирован, но это не является обязательным требованием.
Результат 1: Результатом функции должен быть массив, содержащий значения узлов двоичного дерева,
считываемые сверху вниз, слева направо. В этом примере возвращаемый массив должен быть:
[7, 4, 9, 2, 6, 8, 10, 1, 3, 5]
Пример 2: Пусть входной массив будет [1, 2, 2, 6, 7, 5]. Этот массив содержит значения следующего
полного двоичного дерева.

                6
              /   \
            2       5
           / \     /
          1   2   7

Обратите внимание, что при обходе этого дерева по порядку создается входной массив.
Вывод 2: Результатом функции должен быть массив, содержащий значения узлов двоичного дерева,
считываемые сверху вниз, слева направо. В этом примере возвращаемый массив должен быть:
[6, 2, 5, 1, 2, 7]."""

# Решение lechevalier, kongny, dorito69, fl970723, 11swswsw, MysticUnicorn8
# Это вообще не обход дерева. Это очень элегантный алгоритм перестановки элементов в списке так,
# чтобы в итоге получить правильный ответ )).
from math import log2


def complete_binary_tree(a):
    queue, res = [a], []

    while queue:
        current = queue.pop(0)
        n = len(current)
        if n == 1:
            res.extend(current)
        else:
            deep = int(log2(n))
            top = (2**deep - 1) // 2 + min(n - 2**deep + 1, 2**(deep - 1))
            res.append(current[top])
            queue.extend([current[:top]] + [current[top + 1:]] * (top + 1 < n))

    return res


def main():
    func = complete_binary_tree
    tests = [
        (func([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
         [7, 4, 9, 2, 6, 8, 10, 1, 3, 5]),
        (func([1, 2, 2, 6, 7, 5]), [6, 2, 5, 1, 2, 7]),
        (func([1]), [1]),
        (func([1, 2, 3, 4, 5, 6]), [4, 2, 6, 1, 3, 5]),
        (func([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
         [7, 3, 9, 1, 5, 8, 10, 0, 2, 4, 6]),
        (func([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]),
         [12, 7, 16, 3, 10, 14, 18, 1, 5, 9, 11, 13, 15, 17, 19, 0, 2, 4, 6, 8]),
    ]
    for t in tests:
        print(["failed", "passed"][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
