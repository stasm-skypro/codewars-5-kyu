#! /usr/bin/env python3

"""ОПИСАНИЕ:
Определение: Согласно Википедии, полное двоичное дерево - это двоичное дерево, в котором каждый
уровень, возможно, за исключением последнего, полностью заполнен, а все узлы на последнем уровне
расположены как можно левее". На странице Википедии, упомянутой выше, также упоминается, что
"Двоичные деревья также могут храниться в порядке следования по ширине как неявная структура данных
в массивах, и если дерево является полным двоичным деревом, этот метод не тратит места".
Ваша задача - написать метод (или функцию), который принимает массив (или список, в зависимости от
языка) целых чисел и, предполагая, что массив упорядочен в соответствии с обходом полного двоичного
дерева в порядке, возвращает массив, содержащий значения дерева в порядке ширины.
Пример 1: Пусть входной массив будет [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Этот массив содержит значения
следующего полного двоичного дерева.
                    _ 7_
                  /      \
                4        9
              /   \     / \
            2      6   8   10
           / \     /
          1   3   5

В этом примере входной массив должен быть отсортирован, но это не является обязательным требованием.
Результат 1: Результатом функции должен быть массив, содержащий значения узлов двоичного дерева,
считываемые сверху вниз, слева направо. В этом примере возвращаемый массив должен быть:
[7, 4, 9, 2, 6, 8, 10, 1, 3, 5]
Пример 2: Пусть входной массив будет [1, 2, 2, 6, 7, 5]. Этот массив содержит значения следующего
полного двоичного дерева.

                6
              /   \
            2       5
           / \     /
          1   2   7

Обратите внимание, что при обходе этого дерева по порядку создается входной массив.
Вывод 2: Результатом функции должен быть массив, содержащий значения узлов двоичного дерева,
считываемые сверху вниз, слева направо. В этом примере возвращаемый массив должен быть:
[6, 2, 5, 1, 2, 7]."""
from math import log2, ceil


def create_tree(a: list):
    """Собираем полное двоичное дерево из заданной последовательности чисел."""
    if len(a) == 1:
        return [a[0]]
    if len(a) == 0:
        return None

    n = len(a)
    deep = int(log2(n))
    top = (2**deep - 1) // 2 + min(n - 2**deep + 1, 2**(deep - 1))
    tree = a[top]

    left_subtree = a[:top]
    left = create_tree(left_subtree)

    right_subtree = a[top + 1:]
    right = create_tree(right_subtree)

    return [tree, left, right]


def travers_level(tree, level, res, n):
    """Проходим по уровням двоичного дерева."""
    if not tree:
        return

    if level == 0:
        if isinstance(tree, list):
            res.append(tree[0])
        elif isinstance(tree, int):
            res.append(tree)
    elif level > 0 and len(res) < n:
        travers_level(tree[1], level - 1, res, n)
        travers_level(tree[2], level - 1, res, n)


def complete_binary_tree(a: list):
    """Обходим двоичное дерево в ширину."""
    tree = create_tree(a)

    n = len(a)
    res = []
    height = ceil(log2(n + 1))
    for i in range(height + 1):
        travers_level(tree, i, res, n)

    return res


def main():
    func = complete_binary_tree
    tests = [
        (func([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
         [7, 4, 9, 2, 6, 8, 10, 1, 3, 5]),
        (func([1, 2, 2, 6, 7, 5]), [6, 2, 5, 1, 2, 7]),
        (func([1]), [1]),
        (func([1, 2, 3, 4, 5, 6]), [4, 2, 6, 1, 3, 5]),
        (func([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
         [7, 3, 9, 1, 5, 8, 10, 0, 2, 4, 6]),
        (func([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]),
         [12, 7, 16, 3, 10, 14, 18, 1, 5, 9, 11, 13, 15, 17, 19, 0, 2, 4, 6, 8]),
    ]
    for t in tests:
        print(["failed", "passed"][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
