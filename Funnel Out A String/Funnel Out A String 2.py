#! /usr/bin/env python3

"""ОПИСАНИЕ:
Представьте воронку, заполненную буквами. Нижняя буква выпадает из воронки на
конвейерную ленту:
  \b,c/  -->   \b,c/
   \a/   -->    \ /
                 a
-------     -------
Если над пробелом есть две буквы, меньшая буква попадает в пробел.
  \b,c/   -->   \  c/
   \ /    -->    \b/
a            a
-------      -------
Конечно, это может создать новый пробел, который также должен быть заполнен
таким же образом:
  \f,e,d/  -->  \f, ,d/
   \  c/   -->   \e,c/
    \b/           \b/
   a            a
  -------      -------
Как только все пробелы над ним будут заполнены, нижняя буква выпадет из воронки
на конвейерную ленту. Процесс продолжается до тех пор, пока все буквы не упадут
на конвейер. (Новые буквы попадают
в конец существующей строки)
ЦЕЛЬ КАТА: вернуть строку на конвейерную ленту после того, как все буквы упадут.
\f, ,d/      \f, ,d/   --> etc -->    \     /
 \e,c/        \e,c/    --> etc -->     \   /
  \b/    -->   \ /     --> etc -->      \ /
a           a   b                   abcdef
-------     -------                 -------
Все буквы в воронке будут уникальными, т. е. при каждом сравнении одна буква
будет строго меньше другой. Воронка будет представлена в виде вложенного списка,
например:
[["d","a","c"],
   ["b","e"],
     ["f"]]
Значение буквы определяется ее кодовой точкой. Примечание: это означает, что
все заглавные буквы определяются как меньшие, чем все строчные буквы, но
оператор сравнения вашего языка, вероятно, обработает это таким образом
автоматически.

Воронки всегда будут "приятными" - в каждом слое будет на 1 предмет больше, чем
в слое ниже, и каждый слой будет заполнен, и, как правило, здесь нет ничего
смешного или неожиданного. Единственными используемыми символами являются
стандартные заглавные и строчные буквы A-Z и az. 
Тесты проходят до 9-слойной воронки.
Полностью проработанный пример
\d,a,c/      \d,a,c/      \d,a,c/ -->  \d   c/
 \b,e/        \b,e/  -->   \  e/  -->   \a,e/
  \f/   -->    \ /   -->    \b/          \b/  -->
                f        f            f
------      -------      -------      -------

\d   c/      \d   c/ -->  \    c/      \    c/
 \a,e/  -->   \  e/  -->   \d,e/        \d,e/  -->
  \ /   -->    \a/          \a/   -->    \ /   -->
f  b        fb           fb           fb  a
------      -------      -------      -------

 \    c/      \    c/      \    c/ -->  \     /
  \  e/        \  e/  -->   \   /  -->   \  c/
   \d/   -->    \ /   -->    \e/          \e/  -->
fba          fba d       fbad          fbad
-------      -------     --------      -------

  \     /      \     /      \     /
   \  c/  -->   \   /        \   /
    \ /          \c/   -->    \ /
fbad e       fbade        fbadec
-------      -------      -------

DONE. Return "fbadec"."""


def funnel_out(funnel: list):
    conv = ""
    funnel = funnel[::-1]
    while funnel[0][0] != '~':
        conv = conv + funnel[0][0]
        funnel[0] = ['~']
        i = 1
        j = 0
        while i < len(funnel):
            x = funnel[i][j]
            y = funnel[i][j+1]
            if x < y:
                funnel[i-1][j] = x
                funnel[i][j] = '~'
            else:
                funnel[i-1][j] = y
                funnel[i][j+1] = '~'
                j = j + 1
            i = i + 1
    return conv


def funnel_out_master1(funnel):
    r = ""
    h = len(funnel)
    while funnel[h - 1][0] != "~":
        r += funnel[h - 1][0]
        funnel[h - 1][0] = "~"
        i = h - 1
        j = 0
        while i > 0:
            x = funnel[i - 1][j]
            y = funnel[i - 1][j + 1]
            if funnel[i - 1][j] < funnel[i - 1][j + 1]:
                funnel[i][j] = funnel[i - 1][j]
                funnel[i - 1][j] = "~"
            else:
                funnel[i][j] = funnel[i - 1][j + 1]
                funnel[i - 1][j + 1] = "~"
                j += 1
            i -= 1
    return r


def funnel_out_master2(funnel):
    if not funnel:
        return ""
    ret = []
    while funnel[-1][-1]:
        j = 0
        ret.append(funnel[-1][j])
        funnel[-1][j] = None
        for i in range(-2, -len(funnel) - 1, -1):
            _, k = min((funnel[i][x] or "\xff", x) for x in (j, j + 1))
            funnel[i + 1][j], funnel[i][k], j = funnel[i][k], funnel[i + 1][
                j], k
    return ''.join(ret)


def main():
    tests = [
        ([["f", "e", "d"], ["b", "c"], ["a"]], "abcdef"),
        ([["d", "a", "c"], ["b", "e"], ["f"]], "fbadec"),
        ([["q"]], "q"),
        ([["b", "c"], ["a"]], "abc"),
        ([["a", "e", "c", "f"], ["d", "i", "h"], ["j", "g"], ["b"]], "bghcfiejda"),
    ]
    func = funnel_out
    for t in tests:
        res = func(t[0])
        print(["fail", "passed"][res == t[1]], res)


if __name__ == "__main__":
    main()
