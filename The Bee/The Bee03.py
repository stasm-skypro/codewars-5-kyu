#!/usr/bin/env python3

"""The Bee.

Описание:
Представьте себе пчелиные соты - поле из шестиугольных ячеек со стороной N.
В верхней левой ячейке A есть пчела. За одно движение она может проползти на одну ячейку вниз,
на одну ячейку вниз-вправо или на одну ячейку вверх-вправо (пчела не ползет вверх и влево).
Напишите функцию, которая выводит количество способов, которыми пчела может переползти из ячейки A
в противоположную ячейку B.

Входные данные:
Функция получает единственное число N - размер шестиугольного поля 2 ≤ N ≤ 200.

Выходные данные:
Функция должна выводить одно целое число - количество способов.

Пример:
the_bee(2) --> 11
the_bee(3) --> 291
the_bee(5) --> 259123."""


def the_bee(n):
    """Наивный алгоритм. Зная размер стороны шестиугольника (например, 2), вычисляем количество
    сот в сетке (для n=2 - это 7). Затем строим связный граф, зная из каких сот в какие пчела может
    переползать, а в какие нет. Затем осуществляем поиск всех возможных путей из соты А в соту В,
    как поиск в глубину для всех возможных путей.
    TODO: Знаю как расчитать количество сот, зная n.  Но не нашёл способа, как посторить граф,
    зная количество сот. Т.е как автоматизировать этот процесс."""

    # Найдём количество ячеек m для заданного числа рёбер n.
    m = 1
    for i in range(1, n + 1):
        m = m + 6 * (i - 1)
    print(m)
    # Построим граф, соотвествующий найденному значению m.
    start_pos = None
    final_pos = None
    if m == 7:
        g = {
            '0': ['1', '2', '3'],
            '1': ['3', '4'],
            '2': ['3', '5'],
            '3': ['4', '5', '6'],
            '4': ['6'],
            '5': ['6'],
            '6': [],
        }
        start_pos = '0'
        final_pos = '6'
    elif m == 19:
        g = {
            '0': ['1', '4', '3'],
            '1': ['2', '5', '4'],
            '2': ['6', '5'],
            '3': ['4', '8', '7'],
            '4': ['5', '9', '8'],
            '5': ['6', '10', '9'],
            '6': ['11', '10'],
            '7': ['8', '12'],
            '8': ['9', '13', '12'],
            '9': ['10', '14', '13'],
            '10': ['11', '15', '14'],
            '11': ['15'],
            '12': ['13', '16'],
            '13': ['14', '17', '16'],
            '14': ['15', '18', '17'],
            '15': ['18'],
            '16': ['17'],
            '17': ['18'],
            '18': [],
        }
        start_pos = '0'
        final_pos = '18'

    def dfs(graph, visited, start, finish):
        """Поиск всех возможных путей из точки start в точку finish.
          Рекурсивный поиск в глубину."""
        if start == finish:
            return 1
        visited.append(start)
        c = 0
        for neighbour in graph[start]:
            if neighbour not in visited:
                c += dfs(graph, visited, neighbour, finish)
        visited.remove(start)
        return c

    cnt = dfs(g, [], start_pos, final_pos)
    return cnt


def the_bee2(n):
    """Я заимствовал этот алгоритм у EgorArh. Сначала я решил пойти по прямому пути. Поскольку
    в условии задачи говориться о ячейках сот с заданным размером ребра, а также говориться о
    возможных перемещениях по этим сотам, то это не что иное как направленный граф. По заданному
    размеру ребра нужно найти количество сот (или вершин графа) и сосединить их в соотвествии
    с условиями перемещения пчелы. Затем нужно осуществить поиск в глубину для всех возможных
    вариантов маршрутов. Посчитать количество вершин графа и посчитать количество маршрутов я смог
    без проблем. Я застрял на сосздании графа. Как зная колчество вершин и связи создать список 
    рёбер или спиок смежности (точнее автоматизировать этот процесс для любого зананного n,
    я не смог). Пришлось искать подсматривать решение у другого..."""

    m = 2 * n - 1
    dp = [[0] * m for _ in range(m)]
    for i in range(n):
        dp[i][0] = dp[0][i] = 1
    for i in range(1, m):
        for j in range(1, m):
            if abs(i - j) < n:
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]
    return dp[m - 1][m - 1]


def the_bee3(n):
    cells = [0]*(2*n+1)
    cells[n] = 1
    for i in range(1, 4 * n - 2):
        for j in range(i % 2 + 1, 2 * n, 2):
            cells[j-1] += cells[j]
            cells[j+1] += cells[j]
    return cells[n]


def main():
    func = the_bee2
    tests = [
        (func(2), 11),
        (func(3), 291),
        (func(5), 259123),
        (func(20), 11419120154603538332020717795),
        (func(33), 706829476133138423874525925298446150375545319299),
        (func(50), 61068096560504518254246449553519425203436341865056944755649047832571626123),
    ]
    for t in tests:
        print(['fail', 'OK'][t[0] == t[1]])


if __name__ == "__main__":
    main()
