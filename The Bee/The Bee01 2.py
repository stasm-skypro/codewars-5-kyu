#!/usr/bin/env python3

"""The Bee.

Описание:
Представьте себе пчелиные соты - поле из шестиугольных ячеек со стороной N.
В верхней левой ячейке A есть пчела. За одно движение она может проползти на одну ячейку вниз,
на одну ячейку вниз-вправо или на одну ячейку вверх-вправо (пчела не ползет вверх и влево).
Напишите функцию, которая выводит количество способов, которыми пчела может переползти из ячейки A
в противоположную ячейку B.

Входные данные:
Функция получает единственное число N - размер шестиугольного поля 2 ≤ N ≤ 200.

Выходные данные:
Функция должна выводить одно целое число - количество способов.

Пример:
the_bee(2) --> 11
the_bee(3) --> 291
the_bee(5) --> 259123."""

from time import perf_counter
cnt = 0

def the_bee(n):
    # Найдём количество ячеек m для заданного числа рёбер n.
    m = 1
    for i in range(1, n + 1):
        m = m + 6 * (i - 1)
    # Построим граф, соотвествующий найденному значению m.
    start_pos = None
    final_pos = None
    if m == 7:
        g = {
            '0': ['1', '3', '2'],
            '1': ['4', '3'],
            '2': ['3', '5'],
            '3': ['4', '6', '5'],
            '4': ['6'],
            '5': ['6'],
            '6': [],
        }
        start_pos = '0'
        final_pos = '6'
    elif m == 19:
        g = {
            '0': ['1', '4', '3'],
            '1': ['2', '5', '4'],
            '2': ['6', '5'],
            '3': ['4', '8', '7'],
            '4': ['5', '9', '8'],
            '5': ['6', '10', '9'],
            '6': ['11', '10'],
            '7': ['8', '12'],
            '8': ['9', '13', '12'],
            '9': ['10', '14', '13'],
            '10': ['11', '15', '14'],
            '11': ['15'],
            '12': ['13', '16'],
            '13': ['14', '17', '16'],
            '14': ['15', '18', '17'],
            '15': ['18'],
            '16': ['17'],
            '17': ['18'],
            '18': [],
        }
        start_pos = '0'
        final_pos = '18'

    def dfs(graph, visited, start, finish):
        global cnt
        """Поиск всех возможных путей из точки start в точку finish.
          Рекурсивный поиск в глубину."""
        if start == finish:
            cnt += 1
            return
        visited += [start]
        for neighbour in graph[start]:
            if neighbour not in visited:
                dfs(graph, visited, neighbour, finish)
        visited.remove(start)
    

    dfs(g, [], start_pos, final_pos)
    print(cnt)
    return cnt


def main():
    start = perf_counter()
    tests = [
        (the_bee(2), 11),
        (the_bee(3), 291),
        # (the_bee(5), 259123),
        # (the_bee(20), 11419120154603538332020717795),
        # (the_bee(33), 706829476133138423874525925298446150375545319299),
        # (the_bee(50), 61068096560504518254246449553519425203436341865056944755649047832571626123),
    ]
    for t in tests:
        print(['fail', 'OK'][t[0] == t[1]])
    print(f">>>code runs in: {(perf_counter() - start):.06f}")


if __name__ == "__main__":
    main()
