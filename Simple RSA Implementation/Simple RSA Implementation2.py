#! /usr/bin/env python3

"""ОПИСАНИЕ:
RSA - широко используемая криптосистема с открытым ключом. Как и другие системы шифрования
с открытым ключом, RSA принимает данные и шифрует их с помощью общедоступного ключа. Затем закрытый
ключ используется для расшифровки данных. Это полезно для отправки данных на серверы, потому что
любой может зашифровать свои собственные данные, но расшифровать их может только сервер, содержащий
закрытый ключ. Движущей силой сложности взлома шифрования RSA является сложность простой
факторизации очень больших чисел. В этом kata вы будете реализовывать объект RSA, который может
шифровать и расшифровывать данные. Для простоты мы просто будем использовать числа вместо строковых
/ текстовых данных.
Вот основная схема того, как работает RSA (смотрите эту ссылку для получения более подробной
информации):
Выберите 2 простых числа с именем p и q
Вычислите модуль n = p * q
Вычислите значение n, которое можно найти по формуле phi(n) = (p - 1) * (q - 1)
Выберите положительное целое число, e которое является взаимно простым для totient (объяснение
взаимно простых чисел см. здесь) - это будет показатель степени, используемый в открытом ключе.
Вычислите модульную мультипликативную инверсию 'e (mod phi(n))' - это будет показатель степени d,
используемый в закрытом ключе - (для получения подробной информации о модульных мультипликативных
инверсиях нажмите здесь). Чтобы зашифровать число m в зашифрованное число c, используйте следующую
формулу: c = m**e (mod n). Чтобы расшифровать число c обратно в исходное число m, используйте
следующую формулу: m = c**d (mod n).
Примечание: Поскольку e обычно это гораздо меньшее число, чем d, шифрование выполняется намного
быстрее, чем дешифрование. На реальной практике (и в этом ката) вам нужно будет реализовать
оптимизированный метод дешифрования, поскольку приведенная выше формула, вероятно, займет слишком
много времени для некоторых из более сложных тестовых случаев.
Ваша задача - создать класс, который при инициализации с помощью некоторых p, q и e сможет
шифровать и расшифровывать числа, используя алгоритм RSA. Вы можете предположить, что тестовые
примеры будут проверять только допустимые входные данные."""

from math import lcm


class Rsa:
    """RSA encryption and decryption."""

    def __init__(self, p, q, e):

        # calculating n
        self.n = p * q

        # calculating totient, t
        t = lcm((p - 1), (q - 1))

        self.e = e

        # calculating privet key, d
        self.d = pow(self.e, -1, t)

    def encrypt(self, m):
        """Performing ecryption."""
        # ct = (mes ** self.e) % self.n
        c = pow(m, self.e, self.n)
        return c

    def decrypt(self, c):
        """Performing decryption"""
        # dt = (mes ** self.d) % self.n
        m = pow(c, self.d, self.n)
        return m


def main():
    rsa = Rsa(61, 53, 17)
    tests = [
        (rsa.encrypt(65), 2790),
        (rsa.decrypt(2790), 65),
    ]
    for t in tests:
        print(['failed', 'passed'][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
