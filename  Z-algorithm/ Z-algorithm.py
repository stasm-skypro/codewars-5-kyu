#! /usr/bin/env python3

"""ОПИСАНИЕ:
Цель этого Ката - напомнить / показать вам, как работает Z-алгоритм, и протестировать вашу
реализацию. Для строки str[0..n-1] массив Z имеет ту же длину, что и строка. Элемент Z[i] массива
Z хранит длину самой длинной подстроки, начинающейся с str[i], которая также является префиксом
str[0..n-1]. Первая запись массива Z имеет меньший смысл, поскольку полная строка всегда является
префиксом самой себя.

Пример:
Индекс: 0 1 2 3 4 5 6 7 8 9 10 11

Текст: "a a b c a a b x a a a a z"

Z значений: [11, 1, 0, 0, 3, 1, 0, 0, 2, 2, 1, 0]
Вашей задачей будет реализовать Z-алгоритм в вашем коде и вернуть Z-массив.
Для пустой строки алгоритм должен возвращать [].
Входные данные: строка str
Результат: Z-массив
например:
выведите zfunc('ababcaba')
[8, 0, 2, 0, 0, 3, 0, 1]

P.S. Обратите внимание, что важной частью этого ката является то, что вы должны использовать
эффективный способ получения Z-массива (O(n)) потому что у Kata есть временной тестовый пример. """


def zfunc(s):
    """Trivial algorithm for O(N2)."""
    n = len(s)
    z = [n] + [0] * (n - 1)
    for i in range(1, n):
        while (i + z[i] < n) and (s[z[i]] == s[i + z[i]]):
            z[i] = z[i] + 1
    return z


def zfunc2(s):
    """Fast algorithm for O(N)."""
    if not s:
        return []

    n = len(s)
    z = [n] + [0] * (n - 1)
    l, r, = 0, 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] = z[i] + 1
        if i + z[i] - 1 > r:
            l = i
            r = i + z[i] - 1
    return z


def main():
    fun = zfunc2
    tests = [
        (fun("ababcaba"), [8, 0, 2, 0, 0, 3, 0, 1]),
        (fun("aabcaabxaaaaz"), [13, 1, 0, 0, 3, 1, 0, 0, 2, 2, 2, 1, 0]),
        (fun("abracadabra"), [11, 0, 0, 1, 0, 1, 0, 4, 0, 0, 1]),
        (fun(""), []),
        (fun("abcabcd"), [7, 0, 0, 3, 0, 0, 0]),
        (fun("abacaba"), [7, 0, 1, 0, 3, 0, 1]),
    ]
    for t in tests:
        print(['failed', 'passed'][t[0] == t[1]], t[0])


if __name__ == "__main__":
    main()
